%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%
%% CTDP Assignment %%
%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%

disp("Results for the CTDP - Assignment, by Nico Schwarzer, ID: 5632297");

% Setting fitting working directory!
cd("C:/Users/Nico/Documents/Uni/2. Sem/CTPD");

%%%%%%%%%%%%%%%%%%%%
%% Payoff - Plots %%
%%%%%%%%%%%%%%%%%%%%

% I simulation arbitrary payoff and Underlying_prices_prices price data for visualization purposes

maturity_price = linspace(1,1501,1501);
Underlying_prices_prices = linspace(1,1501,1501);

% Differentiation:
% 1 -- Barrier is hit during lifetime
% 2 -- Barrier is not hit during lifetime

%% Case 1 --  barrier hit  during lifetime %%

% payout of certificate

cert = linspace(1,1501,1501);

figure;
plot(maturity_price, Underlying_prices_prices, "b", 'LineWidth',2.0);
% hold on;
%plot(maturity_price, cert, "--", 'LineWidth',2.0);
yline(0.5*1000, "--", 'LineWidth',2.0);
yline(1200, "--", 'LineWidth',2.0);
text(50, 600, 'Barrier', 'FontSize', 15);
text(50, 1300, 'Bonus level', 'FontSize', 15);
title("Barrier hit", 'FontSize', 18);
legend({'Payoff of Underlying & certificate' }, 'Location','southeast', 'FontSize', 16);
set(gca, 'Xtick', [], 'Ytick', []);
xlabel('Price of Underlying', 'FontSize', 18);
ylabel('Payoffs', 'FontSize', 18);
grid();


%% Case 2 --  barrier not hit  during lifetime %%

% payout of certificate
% barrier at 600, bonus at 1300 in this ficticious example 

cert_1 = linspace(1,500,500)';
cert_2 = ones((1200-500),1) * 1200;
cert_3 = linspace(1200,1501,301)';
cert = [cert_1; cert_2; cert_3];


figure();
plot(maturity_price', Underlying_prices_prices', "r", 'LineWidth',2.0);
hold on;
plot(maturity_price', cert', "b", 'LineWidth',2.0);
yline(0.5*1000, "--", 'LineWidth',2.0);
yline(1200, "--", 'LineWidth',2.0);
text(50, 600, 'Barrier', 'FontSize', 15);
text(50, 600, 'Barrier', 'FontSize', 15);
text(50, 1300, 'Bonus', 'FontSize', 15);
title("Barrier not hit", 'FontSize', 18);
legend({'Payoff of Underlying', 'Payoff of certificate'}, 'Location','southeast', 'FontSize', 16);
xlabel('Price of Underlying', 'FontSize', 18);
ylabel('Payoffs', 'FontSize', 18);
patch([maturity_price' fliplr(maturity_price')], [cert fliplr(Underlying_prices_prices')] , [0.4660, 0.6740, 0.1880]); 
set(gca, 'Xtick', [], 'Ytick', []);
grid;




%%%%%%%%%%%%%%%%%%%%%
%% Loading in data %%
%%%%%%%%%%%%%%%%%%%%%

% I am loading in the data and perform first manipulations 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% prices of the bonus certificate %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

DATA_TABLE_certificate = readtable("snapshot_history_derivative.csv");

cert_date =  DATA_TABLE_certificate{:,1 };
Date = datetime(cert_date);
cert_closing =  DATA_TABLE_certificate{:,3 };
cert_closing = str2double(cert_closing) / 100;
DATA_TABLE_certificate = table(Date, cert_closing);
DATA_TABLE_certificate.Properties.VariableNames = {'Date', 'Closing_cert'};

% checking for NAs
a = sum(isnan(cert_closing)); % 0 - nice
disp("There are " + a + " nans in the data table concerning the certificate");


%re-arranging - so that oldest pbservations are in the upper rows
DATA_TABLE_certificate = sortrows(DATA_TABLE_certificate);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% prices of the underlying stock  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% reading data from 26-02-2016, i.e. 5 years preceding the start of the
% valuation period. One needs this time window for the 5-year moving avrgae
% of returns

DATA_TABLE_underlying = readtable("snapshot_history_RWE.csv");

stock_date =  DATA_TABLE_underlying{:,1 };
Date = datetime(stock_date);
stock_closing1 =  DATA_TABLE_underlying{:,5 };



% checking for NAs
a2 = sum(isnan(stock_closing1)); % 0 - nice
disp("There are " + a2 + " nans in the data table concerning the underlying");

% important: when reading in the stock prices, some price dates do not
% consider the comma, i.e. these are 100 fold too high - taackling this:
stock_closing = ones(size(stock_closing1,1), 1);

for i = 1:size(stock_closing,1)
    if stock_closing1(i,1) > 1000
        stock_closing(i,1) = stock_closing1(i,1) * 0.01;
    else
        stock_closing(i,1) = stock_closing1(i,1);
    end
end

        
% calculating rolling volatitly sigma of stock prices - for 100 and 250 days
rol_var_100_close = movstd(stock_closing,100);
rol_var_250_close = movstd(stock_closing,250);

% calculating (logarithmic) returns 
ln_returns = diff(log(stock_closing));

% calculating rolling volatitly of stock price returns - for 100 and 250 days
% these can be used as proxys for sigma(see sl. 111)

rol_var_100_ret = movstd(ln_returns,100);
rol_var_250_ret = movstd(ln_returns,250);


% first values of returns and volatility of returns needs to be added 
% to ensure same dimensions 
ln_returns = [0;ln_returns];
rol_var_100_ret = [0;rol_var_100_ret];
rol_var_250_ret = [0;rol_var_250_ret];

DATA_TABLE_underlying = table(Date, stock_closing, rol_var_100_close, rol_var_250_close, ln_returns, rol_var_100_ret, rol_var_250_ret);



%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Barrier ever breached %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%

% checking of the barrier was breached from 28-08-2020 onwards:

DATA_TABLE_underlying_2 = DATA_TABLE_underlying(DATA_TABLE_underlying.Date > "2020-08-27", :);

min_price = min(DATA_TABLE_underlying_2.stock_closing);

if min_price > 29.65
    disp("The barrier was not breached");
else 
    disp("The barrier was already breached");
end

% the barrier was not breached! Hence, the option for a bonus payoff
% exists!


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Reading in data for risk free rate %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% I shall read in the parameters needed for the svennsonn method 
%to plug these together with the time to maturity into the formula
% for the risk free rate in the DATA_TABLE_ALL!


% beta 0
df_beta_0 = readtable("beta_0.csv");

rate_date =  df_beta_0{:,1 }; % extracting the dates
Date = datetime(rate_date);

beta_0 =  df_beta_0{:,2 };
beta_0 = str2double(beta_0);

% beta 1 
df_beta_1 = readtable("beta_1.csv");

beta_1 =  df_beta_1{:,2 };
beta_1 = str2double(beta_1);

% beta 2 
df_beta_2 = readtable("beta_2.csv");

beta_2 =  df_beta_2{:,2 };
beta_2 = str2double(beta_2);

% beta 3 
df_beta_3 = readtable("beta_3.csv");

beta_3 =  df_beta_3{:,2 };
beta_3 = str2double(beta_3);

% tau 1
df_tau_1 = readtable("tau_1.csv");

tau_1 =  df_tau_1{:,2 };
tau_1 = str2double(tau_1);

% tau 2
df_tau_2 = readtable("tau_2.csv");

tau_2 =  df_tau_2{:,2 };
tau_2 = str2double(tau_2);


% replacing all NANs with last non-nan value (respectively) 
% therefore first obervations since they are all nans  in the beginning


for i = 1:size(beta_0,1)
    if sum(isnan(beta_0(i,1))) == 1
        beta_0(i,1) = beta_0((i-1),1);
    end
end

for i = 1:size(beta_1,1)
    if sum(isnan(beta_1(i,1))) == 1
        beta_1(i,1) = beta_1((i-1),1);
    end
end

for i = 1:size(beta_2,1)
    if sum(isnan(beta_2(i,1))) == 1
        beta_2(i,1) = beta_2((i-1),1);
    end
end

for i = 1:size(beta_3,1)
    if sum(isnan(beta_3(i,1))) == 1
        beta_3(i,1) = beta_3((i-1),1);
    end
end

for i = 1:size(tau_1,1)
    if sum(isnan(tau_1(i,1))) == 1
        tau_1(i,1) = tau_1((i-1),1);
    end
end


for i = 1:size(tau_2,1)
    if sum(isnan(tau_2(i,1))) == 1
        tau_2(i,1) = tau_2((i-1),1);
    end
end

% Importantly, when reading in the svensson parameters, these are
% 10,000-fold or 100,000-fold to high since the comma is not picked up 
% by MATLAB. Tackling this:

beta_0 = beta_0 / 100 / 100;
beta_1 = beta_1 / 100 / 1000;
beta_2 = beta_2 / 100 / 1000;
beta_3 = beta_3 / 100 / 1000;
tau_1 = tau_1 / 100 / 1000;
tau_2 = tau_2 / 100 / 1000;


DATA_TABLE_interest = table(Date, beta_0, beta_1, beta_2, beta_3, tau_1, tau_2);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Preparation for the Valuation %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
rng(1);


% creating a joint data table -  calling it "DATA_TABLE_ALL" %

% merging with stock_df
DATA_TABLE_JOIN1 = outerjoin(DATA_TABLE_certificate, DATA_TABLE_underlying);

% merging with interest rates dataframe
DATA_TABLE_interest.Properties.VariableNames = {'Date_DATA_TABLE_underlying', 'beta_0', 'beta_1', 'beta_2', 'beta_3', 'tau_1', 'tau_2'};

DATA_TABLE_JOIN2 = outerjoin(DATA_TABLE_JOIN1, DATA_TABLE_interest);


% I only use the last 101 rows - these 101 days will be used as valuation
% window!
size_merge = size(DATA_TABLE_JOIN2,1) -1;
s2 = size_merge - 101;
DATA_TABLE_ALL = DATA_TABLE_JOIN2(s2:size_merge,:);    %calling the final DF 'DATA_TABLE_ALL'


% keeping only one date column
val_sing_date = DATA_TABLE_ALL;
val_sing_date = val_sing_date(:,[ 2 4 5 6 7 8 9 10 11 12 13 14 15 16]);
DATA_TABLE_ALL = val_sing_date;


% removing nans, i.e. replacing them by preceding values - creating matrix without date column
% to make this computationally efficient 
DATA_TABLE_ALL_NO_DATES = DATA_TABLE_ALL(:,[ 1 2 3 4 5 6 7  9 10 11 12 13 14]);

col_names = DATA_TABLE_ALL_NO_DATES.Properties.VariableNames; % keeping these since as column names for later tables
DATA_TABLE_ALL_NO_DATES = table2array(DATA_TABLE_ALL_NO_DATES);


% replacing the nans 
for a = 1:size(DATA_TABLE_ALL_NO_DATES,2)
    for i = 1:size(DATA_TABLE_ALL_NO_DATES,1)
        if sum(isnan(DATA_TABLE_ALL_NO_DATES(i,a))) == 1
            DATA_TABLE_ALL_NO_DATES(i,a) = DATA_TABLE_ALL_NO_DATES((i-1),a);
        end
    end
end



% getting the DATA_TABLE_ALL data table again
DATA_TABLE_ALL_NO_DATES = array2table(DATA_TABLE_ALL_NO_DATES);
DATA_TABLE_ALL_NO_DATES.Properties.VariableNames =    {'Closing_cert','stock_closing','rol_var_100_close','rol_var_250_close','ln_returns','rol_var_100_ret','rol_var_250_ret','beta_0','beta_1','beta_2','beta_3','tau_1','tau_2'};
DATA_TABLE_ALL_NO_DATES.Date = DATA_TABLE_ALL.Date_DATA_TABLE_underlying_DATA_TABLE_interest;

%caling the table 'DATA_TABLE_ALL' again
DATA_TABLE_ALL = DATA_TABLE_ALL_NO_DATES;


    
%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Window for valuation %%
%%%%%%%%%%%%%%%%%%%%%%%%%%

% Here, I am determining the time window which is considered in the
% valuation analysis 

% Beginning of valuation period:
BEGINNING_DATE = DATA_TABLE_ALL.Date(1,1) ;

% Considerung date of maturity:
ENDING_DATE = "2022-08-19";
DAYS_UNTIL_MATURITY = string( (ENDING_DATE - BEGINNING_DATE) / 24 );
DAYS_UNTIL_MATURITY = char(DAYS_UNTIL_MATURITY);
rdc = DAYS_UNTIL_MATURITY(1:3);
disp("There are " + rdc + " days in between the first date of the valuation period and the end on the lifetime of the certificate");

% numercic value for the # days 
rest_d = str2double(rdc);


% finally adding a variable / a column that contains info on the 
% days until maturity ( T -t in Black Scholes)
rest_days = linspace(rest_d, (rest_d-101),102)';
DATA_TABLE_ALL.rest_days = rest_days;

%size(DATA_TABLE_ALL)
%size(rest_days)


% final date of valuation period 
date_end = DATA_TABLE_ALL.Date(size(DATA_TABLE_ALL,1),1) ;

disp("The valuation period extends from " + string(BEGINNING_DATE) + " to " + string(date_end) );



%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Daily risk free rate %%
%%%%%%%%%%%%%%%%%%%%%%%%%%

% now that one has all svensson parameters as well as the days until
% marituy, one can calculate the risk free rate measure

% instentiating vector
risk_f_r = zeros(size(DATA_TABLE_ALL,1),1);

% filling it in 
for a = 1:size(DATA_TABLE_ALL,1)
    m = DATA_TABLE_ALL.rest_days(a,1)  / 365;
    risk_f_r(a,1) = ( DATA_TABLE_ALL.beta_0(1,1) + DATA_TABLE_ALL.beta_1(a,1) * exp( - m / DATA_TABLE_ALL.tau_1(a,1) ) + DATA_TABLE_ALL.beta_2(a,1) * ( - m / DATA_TABLE_ALL.tau_1(a,1) ) + DATA_TABLE_ALL.beta_3(a,1) * m / DATA_TABLE_ALL.tau_2(a,1) * exp(- m / DATA_TABLE_ALL.tau_2(a,1) )  ) * 0.01;
end 


% adding it to DATA_TABLE_ALL data table 
DATA_TABLE_ALL.risk_f_r = risk_f_r;


% removing the svensson parameters from the DATA_TABLE_ALL data table for
% simplicity!

DATA_TABLE_ALL = DATA_TABLE_ALL(:, [ 1 2 3 4 5 6 7 14 15 16 ]);


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Black Scholes Valuation %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
rng(1);


% this part will primaly deal with the (complex) calculation of the down
% and out put part of the bonus certificate as suggested by Hull 
% (p.604-606)



%% Using the 100 days rolling volatility as sigma
rng(1);

% adding two arrays which shall contain the info on the valuation of 
% the certificate using 100 (and 250-) days rolling volatility 

valuation_100 = ones(102,1);
valuation_250 = ones(102,1);


    % obtaining general data
    H = 29.65;
    K = 37.5 ;

for x = 1:102
    
    % obtaining data from respective row
    T = DATA_TABLE_ALL;
    S = table2array(T(x,2)); % stock prices
    si =  table2array(T(x,6)); % volatility
    t =   table2array(T(x,9) ); % days to maturity
    r = table2array(T(x,10)); % risk free rate
    q = r; %  replacing stock drift by risk free rate - see sl. 107


    % now calling the function 'value_Black_Scholes'
    
    valuation_100(x) = value_Black_Scholes( S, si, r, t );
 
end


%% Using the 250 days rolling volatility as sigma
rng(1);



for x = 1:102
    
    % obtaining data from respective row
    T = DATA_TABLE_ALL;
    S = table2array(T(x,2)); % stock prices
    si =  table2array(T(x,6)); % volatility
    t =   table2array(T(x,9) ) ; % days to maturity
    r = table2array(T(x,10)); % risk free rate
    q = r; %  replacing stock drift by risk free rate - see sl. 107

    
    % now calling the function 'value_Black_Scholes'
    
    valuation_250(x) = value_Black_Scholes( S, si, r, t );
 
end


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% checking for differences in the valuation methods %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

differences = valuation_100 - valuation_250;
max_diff = max(differences);

if max_diff < 0.2
   disp("The valuations using the different rolling volatilities are extremely similar, hence only the results using the 100 days rolling volatility are reported.") 
end



% Since there differences are aprox. 0, I will only consider the method of
% using the 100 days rolling standard deviation (volatility) as sigma

%%%%%%%%%%%%%%%%%%%%%%%%%%
%% plotting the results %%
%%%%%%%%%%%%%%%%%%%%%%%%%%

figure();
plot(DATA_TABLE_ALL.Date, DATA_TABLE_ALL.Closing_cert, "--", 'LineWidth',2.0);
hold on;
plot(DATA_TABLE_ALL.Date, valuation_100, "b", 'LineWidth',2.0);
%hold on;
%plot(DATA_TABLE_ALL.Date, valuation_250, "r");
%xlabel('Period of valuation', 'FontSize', 18);
ylabel('Prices - in €', 'FontSize', 18);
legend({'Observed market value', 'Valuation using 100 days rolling volatility'}, 'Location','southeast', 'FontSize', 12);
%ylim([28 35]);
%tstart = datetime(2021,2,2);
%tend = datetime(2018,6,6);
%xlim([tstart tend]);
grid;



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% computing error measurements %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% I shall not compute the errors of the valuation method using the 250-days
%rolling volatility as argued above

% absolute error
abs_error_100 = mean(abs(valuation_100 - DATA_TABLE_ALL.Closing_cert));
%abs_error_250 = mean(abs(valuation_250 - DATA_TABLE_ALL.Closing_cert));

% RMSE
rmse_100 = sqrt( mean((valuation_100 - DATA_TABLE_ALL.Closing_cert).^2) );
%rmse_250 = sqrt( mean((valuation_250 - DATA_TABLE_ALL.Closing_cert).^2) );

% quantiles of the absolute error
abs_errors = abs(valuation_100 - DATA_TABLE_ALL.Closing_cert);

quant_25 = quantile(abs_errors, 0.25); quant_50 = quantile(abs_errors, 0.5); quant_75 = quantile(abs_errors, 0.75);

disp("Results of the error metrics:");
disp("The mean absolute error is: " + abs_error_100 + ".");
disp("The root mean sqaured error is: " + rmse_100 + ".");
disp("The 0.25 quantile of the absolute error is: "  + quant_25 + " while that of the 50%-quantile is: " + quant_50 + " and that of the 75%-quantile is: " + quant_75 + ".");


%%%%%%%%%%%%
%% Greeks %%
%%%%%%%%%%%%

% in the following, the Greeks Delta, Gamma & Vega are obtained using
% simulations. I shall always use equidistant steps for the underlying from 25€ to 40€
%  in 1000 equidistant steps 

underlyings = linspace(29.65,42,1000)';


%%%%%%%%%%%%
%% deltas %%
%%%%%%%%%%%%


rng(1);

%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 120 days to maturity  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%

T = DATA_TABLE_ALL;
si= 0.4; % choosen arbitrarily 
t =   120/365;
r = 0.02;
q = -0.055;  % choosen arbitrarily

% the valuation will be done as above - that is why I shall remove
% unnessecary comments to save space 

% creating empty array to be filled in 
deltas = ones(1000,1);

% since one needs to consider a higher and lower stock price and the actual
% stock price and derive the certificate prices from them 

value_certificate_higher = ones(1000,1);
value_certificate_lower = ones(1000,1);

for d = 1:1000

    %%%%%%%%%%%%%%%%%%%%%%%%%
    % pricing derivate with stock price + 0.5 
    % increasing stock price 
    S = underlyings(d,1) + 0.5;
    
        % Same code as in value_Black_Scholes function 
        lambda = (r - q + 0.5*si ^2) / si ^2  ; % maybe just si? - for all!
        y = log(H^2/ S*K)/(si*sqrt(t)) + lambda * si * sqrt(t);
        x1 = log(S/H)/(si*sqrt(t)) + lambda * si* sqrt(t);  % or S0 
        y1 = log(H/S)/(si*sqrt(t)) + lambda * si* sqrt(t);  % or S0
        d1 = ( log(S/K) + (r-q+0.5*si^2)*t )/ (si * sqrt(t));
        d2 = d1 - si * sqrt(t);
        p = K * exp(-r*t) * normcdf(-d2) - S * exp(-q*t) * normcdf(-d1);
        p_di_1 = -S*normcdf(-x1) *exp(-q*t) + K * exp(-r*t) * normcdf(-x1 + si * sqrt(t) ) + S *exp(-q*t) * ( normcdf(y) - normcdf(y1) ) * (H/S)^(2*lambda);
        p_di_2 = - K * exp(-r*t) * ( normcdf(y-si*sqrt(t)) - normcdf(y1-si*sqrt(t))  )* (H/S) ^ (2*lambda - 2) ;
        p_di = p_di_1 + p_di_2;
        p_do = p - p_di;

        % valuation of certificate:
        value_certificate_higher = S + p_do;

    %%%%%%%%%%%%%%%%%%%%%%%%%
    % pricing derivate with stock price -  0.5 
    % increasing stock price 
    S = underlyings(d,1) - 0.5;
    
    % Same code as in value_Black_Scholes function 
        lambda = (r - q + 0.5*si ^2) / si ^2  ; % maybe just si? - for all!
        y = log(H^2/ S*K)/(si*sqrt(t)) + lambda * si * sqrt(t);
        x1 = log(S/H)/(si*sqrt(t)) + lambda * si* sqrt(t);  % or S0 
        y1 = log(H/S)/(si*sqrt(t)) + lambda * si* sqrt(t);  % or S0
        d1 = (log(S/K) + (r-q+0.5*si^2)*t )/ (si * sqrt(t));
        d2 = d1 - si * sqrt(t);
        p = K * exp(-r*t) * normcdf(-d2) - S * exp(-q*t) * normcdf(-d1);
        p_di_1 = -S*normcdf(-x1) *exp(-q*t) + K * exp(-r*t) * normcdf(-x1 + si * sqrt(t) ) + S *exp(-q*t) * ( normcdf(y) - normcdf(y1) ) * (H/S)^(2*lambda);
        p_di_2 = - K * exp(-r*t) * ( normcdf(y-si*sqrt(t)) - normcdf(y1-si*sqrt(t))  )* (H/S) ^ (2*lambda - 2) ;
        p_di = p_di_1 + p_di_2;
        p_do = p - p_di;

        % valuation of certificate:
        value_certificate_lower = S + p_do;
    

     % now calculating the deltas % 
     deltas(d,1) = value_certificate_higher - value_certificate_lower;

    
end


% adding delta = 1 for a stock price of lower than 29.65 
% we know that delta has to be 1 in this case!
% However, a simulation would not return this since the higher stock values
% (+0.5) are already above the barrier - leading to unnesessary distortions

delta_1 = ones(100,1);
underlyings_1 = linspace(27,29.65,100)';

deltas_total = [delta_1; deltas];
underl_total = [ underlyings_1; underlyings];


%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 80 days to maturity  %%
%%%%%%%%%%%%%%%%%%%%%%%%%%


% using the same data (sigma, stock price etc.)
%just different time to maturity
t =   80 / 365;

% the valuation will be done as above - that is why I shall remove
% unnessecary comments to save space 

% creating empty array to be filled in 
deltas_80 = ones(1000,1);

% since one needs to consider a higher and lower stock price and the actual
% stock price and derive the certificate prices from them 
value_certificate_higher = ones(1000,1);
value_certificate_lower = ones(1000,1);

for d = 1:1000

    %%%%%%%%%%%%%%%%%%%%%%%%%
    % pricing derivate with stock price + 0.5 
    % increasing stock price 
    S = underlyings(d,1) + 0.5;
    
        % Same code as in value_Black_Scholes function 
        lambda = (r - q + 0.5*si ^2) / si ^2  ; % maybe just si? - for all!
        y = log(H^2/ S*K)/(si*sqrt(t)) + lambda * si * sqrt(t);
        x1 = log(S/H)/(si*sqrt(t)) + lambda * si* sqrt(t);  % or S0 
        y1 = log(H/S)/(si*sqrt(t)) + lambda * si* sqrt(t);  % or S0
        d1 = (log(S/K) + (r-q+0.5*si^2)*t )/ (si * sqrt(t));
        d2 = d1 - si * sqrt(t);
        p = K * exp(-r*t) * normcdf(-d2) - S * exp(-q*t) * normcdf(-d1);
        p_di_1 = -S*normcdf(-x1) *exp(-q*t) + K * exp(-r*t) * normcdf(-x1 + si * sqrt(t) ) + S *exp(-q*t) * ( normcdf(y) - normcdf(y1) ) * (H/S)^(2*lambda);
        p_di_2 = - K * exp(-r*t) * ( normcdf(y-si*sqrt(t)) - normcdf(y1-si*sqrt(t))  )* (H/S) ^ (2*lambda - 2) ;
        p_di = p_di_1 + p_di_2;
        p_do = p - p_di;

        % valuation of certificate:
        value_certificate_higher = S + p_do;

    %%%%%%%%%%%%%%%%%%%%%%%%%
    % pricing derivate with stock price -  0.5 
    % increasing stock price 
    S = underlyings(d,1) - 0.5;
    
        % Same code as in value_Black_Scholes function 
        lambda = (r - q + 0.5*si ^2) / si ^2  ; % maybe just si? - for all!
        y = log(H^2/ S*K)/(si*sqrt(t)) + lambda * si * sqrt(t);
        x1 = log(S/H)/(si*sqrt(t)) + lambda * si* sqrt(t);  % or S0 
        y1 = log(H/S)/(si*sqrt(t)) + lambda * si* sqrt(t);  % or S0
        d1 = (log(S/K) + (r-q+0.5*si^2)*t )/ (si * sqrt(t));
        d2 = d1 - si * sqrt(t);
        p = K * exp(-r*t) * normcdf(-d2) - S * exp(-q*t) * normcdf(-d1);
        p_di_1 = -S*normcdf(-x1) *exp(-q*t) + K * exp(-r*t) * normcdf(-x1 + si * sqrt(t) ) + S *exp(-q*t) * ( normcdf(y) - normcdf(y1) ) * (H/S)^(2*lambda);
        p_di_2 = - K * exp(-r*t) * ( normcdf(y-si*sqrt(t)) - normcdf(y1-si*sqrt(t))  )* (H/S) ^ (2*lambda - 2) ;
        p_di = p_di_1 + p_di_2;
        p_do = p - p_di;

        % valuation of certificate:
        value_certificate_lower = S + p_do;
    

     % now calculating the deltas % 
     deltas_80(d,1) = value_certificate_higher - value_certificate_lower;

    
end


% again:
% adding delta = 1 for a stock price of lower than 29.65
% we know that delta has to be 1 in this case!
% However, a simulation would not return this since the higher stock values
% (+0.5) are already above the barrier - leading to unnesessary distortions

delta_1_80 = ones(100,1);

deltas_total_80 = [delta_1_80; deltas_80];


%%%%%%%%%%%%%%%%%%%%%%%%%%
%% plotting the results %%
%%%%%%%%%%%%%%%%%%%%%%%%%%


figure;
plot(underl_total, deltas_total, "--", 'LineWidth',2.0);
hold on;
plot(underl_total, deltas_total_80, "b", 'LineWidth',2.0);
xline(29.65, "--", 'LineWidth',2.0);
xline(37.5, "--",   'LineWidth',2.0);
xlabel('Stock prices', 'FontSize', 18);
title("Delta", 'FontSize', 18);
legend({'120 days to maturity', '80 days to maturity' }, 'Location','southeast', 'FontSize', 16);
%xlim([28, 42]);
%ylim([0.95, 1.38]);
grid();



%%%%%%%%%%%
%% Gamma %%
%%%%%%%%%%%

rng(1);

% As was done with Delta - simulate this greek for 2 different days
% i.e. also for 120 and 80 days until maturity

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 120 days until maturity %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

T = DATA_TABLE_ALL;
S1 = table2array(T(1,2));
si= 0.5; % choosen arbitrarily
t =   120 / 365; %table2array(T(1,10) ) ;
r = 0.01;% choosen arbitrarily
q = -0.055; % choosen arbitrarily


% the valuation will be done as above - that is why I shall remove
% unnessecary comments to save space 

% creating empty array to be filled in 
gammas = ones(1000,1);


% since one needs to consider a higher, a lower stock price and the actual
% stock price and derive the certificate prices from them 

value_certificate = ones(1000,1);
value_certificate_higher = ones(1000,1);
value_certificate_lower = ones(1000,1);

for d = 1:1000




            %%%%%%%%%%%%%%%%%%%%%%%%%
    % pricing derivate with stock price + 1 
    % increasing stock price 
    S = underlyings(d,1) + 1;
    
        % Same code as in value_Black_Scholes function 
        lambda = (r - q + 0.5*si ^2) / si ^2  ; % maybe just si? - for all!
        y = log(H^2/ S*K)/(si*sqrt(t)) + lambda * si * sqrt(t);
        x1 = log(S/H)/(si*sqrt(t)) + lambda * si* sqrt(t);  % or S0 
        y1 = log(H/S)/(si*sqrt(t)) + lambda * si* sqrt(t);  % or S0
        d1 = (log(S/K) + (r-q+0.5*si^2)*t )/ (si * sqrt(t));
        d2 = d1 - si * sqrt(t);
        p = K * exp(-r*t) * normcdf(-d2) - S * exp(-q*t) * normcdf(-d1);
        p_di_1 = -S*normcdf(-x1) *exp(-q*t) + K * exp(-r*t) * normcdf(-x1 + si * sqrt(t) ) + S *exp(-q*t) * ( normcdf(y) - normcdf(y1) ) * (H/S)^(2*lambda);
        p_di_2 = - K * exp(-r*t) * ( normcdf(y-si*sqrt(t)) - normcdf(y1-si*sqrt(t))  )* (H/S) ^ (2*lambda - 2) ;
        p_di = p_di_1 + p_di_2;
        p_do = p - p_di;

        % valuation of certificate:
        value_certificate_higher = S + p_do;

        
    %%%%%%%%%%%%%%%%%%%%%%%%%
    % pricing derivate with unchanged stock price 
    % increasing stock price 
    
    S = underlyings(d,1);
    
        % Same code as in value_Black_Scholes function 
        lambda = (r - q + 0.5*si ^2) / si ^2  ; % maybe just si? - for all!
        y = log(H^2/ S*K)/(si*sqrt(t)) + lambda * si * sqrt(t);
        x1 = log(S/H)/(si*sqrt(t)) + lambda * si* sqrt(t);  % or S0 
        y1 = log(H/S)/(si*sqrt(t)) + lambda * si* sqrt(t);  % or S0
        d1 = (log(S/K) + (r-q+0.5*si^2)*t )/ (si * sqrt(t));
        d2 = d1 - si * sqrt(t);
        p = K * exp(-r*t) * normcdf(-d2) - S * exp(-q*t) * normcdf(-d1);
        p_di_1 = -S*normcdf(-x1) *exp(-q*t) + K * exp(-r*t) * normcdf(-x1 + si * sqrt(t) ) + S *exp(-q*t) * ( normcdf(y) - normcdf(y1) ) * (H/S)^(2*lambda);
        p_di_2 = - K * exp(-r*t) * ( normcdf(y-si*sqrt(t)) - normcdf(y1-si*sqrt(t))  )* (H/S) ^ (2*lambda - 2) ;
        p_di = p_di_1 + p_di_2;
        p_do = p - p_di;

        % valuation of certificate:
        value_certificate = S + p_do;
    
        %%%%%%%%%%%%%%%%%%%%%%%%%
    % pricing derivate with lower stock price 
    % increasing stock price 
    
    S = underlyings(d,1) - 1;
    
       % Same code as in value_Black_Scholes function 
       lambda = (r - q + 0.5*si ^2) / si ^2  ; % maybe just si? - for all!
        y = log(H^2/ S*K)/(si*sqrt(t)) + lambda * si * sqrt(t);
        x1 = log(S/H)/(si*sqrt(t)) + lambda * si* sqrt(t);  % or S0 
        y1 = log(H/S)/(si*sqrt(t)) + lambda * si* sqrt(t);  % or S0
        d1 = (log(S/K) + (r-q+0.5*si^2)*t )/ (si * sqrt(t));
        d2 = d1 - si * sqrt(t);
        p = K * exp(-r*t) * normcdf(-d2) - S * exp(-q*t) * normcdf(-d1);
        p_di_1 = -S*normcdf(-x1) *exp(-q*t) + K * exp(-r*t) * normcdf(-x1 + si * sqrt(t) ) + S *exp(-q*t) * ( normcdf(y) - normcdf(y1) ) * (H/S)^(2*lambda);
        p_di_2 = - K * exp(-r*t) * ( normcdf(y-si*sqrt(t)) - normcdf(y1-si*sqrt(t))  )* (H/S) ^ (2*lambda - 2) ;
        p_di = p_di_1 + p_di_2;
        p_do = p - p_di;

        % valuation of certificate:
        value_certificate_lower = S + p_do;
        % now calculating the deltas % 
        gammas(d,1) = value_certificate_lower - 2*value_certificate + value_certificate_higher;

end


% adding delta = 1 for a stock price of lower than 29.65 
% we know that delta has to be 1 in this case!
% However, a simulation would not return this since the higher stock values
% (+0.5) are already above the barrier - leading to unnesessary distortions

gammas_1 = zeros(100,1);
underlyings_1 = linspace(27,29.65,100)';

gammas_total = [gammas_1; gammas];
underl_total = [ underlyings_1; underlyings];

%%%%%%%%%%%%%%%%%%%%%%%%%%
%% 80 days to maturity %%
%%%%%%%%%%%%%%%%%%%%%%%%%%

% as before, keeping all other hyperparamters alike but simulating the
% gammas for 100 days until maturity
t = 80 / 365;
gammas_80 = ones(1000,1);


% since one needs to consider a higher, a lower stock price and the actual
% stock price and derive the certificate prices from them 

value_certificate = ones(1000,1);
value_certificate_higher = ones(1000,1);
value_certificate_lower = ones(1000,1);

for d = 1:1000



            %%%%%%%%%%%%%%%%%%%%%%%%%
    % pricing derivate with stock price + 1 
    % increasing stock price 
    S = underlyings(d,1) + 1;
    
        % Same code as in value_Black_Scholes function 
        lambda = (r - q + 0.5*si ^2) / si ^2  ; % maybe just si? - for all!
        y = log(H^2/ S*K)/(si*sqrt(t)) + lambda * si * sqrt(t);
        x1 = log(S/H)/(si*sqrt(t)) + lambda * si* sqrt(t);  % or S0 
        y1 = log(H/S)/(si*sqrt(t)) + lambda * si* sqrt(t);  % or S0
        d1 = (log(S/K) + (r-q+0.5*si^2)*t )/ (si * sqrt(t));
        d2 = d1 - si * sqrt(t);
        p = K * exp(-r*t) * normcdf(-d2) - S * exp(-q*t) * normcdf(-d1);
        p_di_1 = -S*normcdf(-x1) *exp(-q*t) + K * exp(-r*t) * normcdf(-x1 + si * sqrt(t) ) + S *exp(-q*t) * ( normcdf(y) - normcdf(y1) ) * (H/S)^(2*lambda);
        p_di_2 = - K * exp(-r*t) * ( normcdf(y-si*sqrt(t)) - normcdf(y1-si*sqrt(t))  )* (H/S) ^ (2*lambda - 2) ;
        p_di = p_di_1 + p_di_2;
        p_do = p - p_di;

        % valuation of certificate:
        value_certificate_higher = S + p_do;

        
    %%%%%%%%%%%%%%%%%%%%%%%%%
    % pricing derivate with unchanged stock price 
    % increasing stock price 
    
    S = underlyings(d,1);
    
        % Same code as in value_Black_Scholes function 
        lambda = (r - q + 0.5*si ^2) / si ^2  ; % maybe just si? - for all!
        y = log(H^2/ S*K)/(si*sqrt(t)) + lambda * si * sqrt(t);
        x1 = log(S/H)/(si*sqrt(t)) + lambda * si* sqrt(t);  % or S0 
        y1 = log(H/S)/(si*sqrt(t)) + lambda * si* sqrt(t);  % or S0
        d1 = (log(S/K) + (r-q+0.5*si^2)*t )/ (si * sqrt(t));
        d2 = d1 - si * sqrt(t);
        p = K * exp(-r*t) * normcdf(-d2) - S * exp(-q*t) * normcdf(-d1);
        p_di_1 = -S*normcdf(-x1) *exp(-q*t) + K * exp(-r*t) * normcdf(-x1 + si * sqrt(t) ) + S *exp(-q*t) * ( normcdf(y) - normcdf(y1) ) * (H/S)^(2*lambda);
        p_di_2 = - K * exp(-r*t) * ( normcdf(y-si*sqrt(t)) - normcdf(y1-si*sqrt(t))  )* (H/S) ^ (2*lambda - 2) ;
        p_di = p_di_1 + p_di_2;
        p_do = p - p_di;

        % valuation of certificate:
        value_certificate = S + p_do;
    
        %%%%%%%%%%%%%%%%%%%%%%%%%
    % pricing derivate with lower stock price 
    % increasing stock price 
    
    S = underlyings(d,1) - 1;
    
        % Same code as in value_Black_Scholes function 
        lambda = (r - q + 0.5*si ^2) / si ^2  ; % maybe just si? - for all!
        y = log(H^2/ S*K)/(si*sqrt(t)) + lambda * si * sqrt(t);
        x1 = log(S/H)/(si*sqrt(t)) + lambda * si* sqrt(t);  % or S0 
        y1 = log(H/S)/(si*sqrt(t)) + lambda * si* sqrt(t);  % or S0
        d1 = (log(S/K) + (r-q+0.5*si^2)*t )/ (si * sqrt(t));
        d2 = d1 - si * sqrt(t);
        p = K * exp(-r*t) * normcdf(-d2) - S * exp(-q*t) * normcdf(-d1);
        p_di_1 = -S*normcdf(-x1) *exp(-q*t) + K * exp(-r*t) * normcdf(-x1 + si * sqrt(t) ) + S *exp(-q*t) * ( normcdf(y) - normcdf(y1) ) * (H/S)^(2*lambda);
        p_di_2 = - K * exp(-r*t) * ( normcdf(y-si*sqrt(t)) - normcdf(y1-si*sqrt(t))  )* (H/S) ^ (2*lambda - 2) ;
        p_di = p_di_1 + p_di_2;
        p_do = p - p_di;

        % valuation of certificate:
        value_certificate_lower = S + p_do;
        % now calculating the deltas % 
        gammas_80(d,1) = value_certificate_lower - 2*value_certificate + value_certificate_higher;

end

% adding delta = 1 for a stock price of lower than 29.65 
% we know that delta has to be 1 in this case!
% However, a simulation would not return this since the higher stock values
% (+0.5) are already above the barrier - leading to unnesessary distortions
gammas_1_80 = zeros(100,1);
gammas_total_80 = [gammas_1_80; gammas_80];



%%%%%%%%%%%%%%%%%%%%%%%%%%
%% plotting the results %%
%%%%%%%%%%%%%%%%%%%%%%%%%%


figure;
plot(underl_total, gammas_total, "--", 'LineWidth',2.0);
hold on;
plot(underl_total, gammas_total_80, "b", 'LineWidth',2.0);
xline(29.65, "--", 'LineWidth',2.0);
xline(37.5, "--",   'LineWidth',2.0);
xlabel('Stock prices', 'FontSize', 18);
title("Gamma", 'FontSize', 18);
legend({'120 days to maturity', '80 days to maturity' }, 'Location','southeast', 'FontSize', 16);
%xlim([28, 42]);
%ylim([-0.12, 0.02]);
grid();


%%%%%%%%%%
%% Vega %%
%%%%%%%%%%




%%%%%%%%%%%%%
%%%%%%%%%%%%%
%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Replicating Portfolio %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%


% Notice: For the RP, I  shall use the "delta_compute" - function, which returns the
% values of delta based on a simulation, which is based on the mathematical
% pricing formula 

rng(1);

% considering the time value of 28.02.2021 to 28.08.2022 ( i.e. maturity)
% i.e. 18 full months to go 

% 28.02. corresponds to the third row in the DATA_TABLE_ALL (or T) data
% table

T_first_date = T(3,:);

% Obtaining stock price, etc.
p1 = table2array(T_first_date(1,2));

% Further parameters to be used below:
sigma = table2array(T_first_date(1,6));

% using the rolling volatility of stock returns 
r = table2array(T(3,10));  % risk-free rate

% using a day-count measure of 12 months, 30 days per month here 
days_to_go = ones(18,1);
dtg = days_to_go; % more efficient code -  iteratively deacreasing this by 30 

% filling in respective values 
dtg(1,1) = 18 * 30; 

for i = 2:18
    dtg(i,1) = dtg((i-1),1) - 30; % iteratively deacreasing this by 30
end


% Importantly, i have re-written the valuation using black scholes as well
% as the simulation for delta in seperate functions to avoid spaghetti code
% below. The functions are called "value" and "delta", respectively.

%%% empy arrays - to be filled in the simulation %%% 

% empty array for stock prices!
values = ones(18,1);

% deltas
deltas = ones(18,1);

% value stocks after updating 
stocks_after = ones(18,1);

% value stocks before updating 
stocks_before = ones(18,1);

% value bonds after updating
bonds_after = ones(18,1);

% value bonds before updating
bonds_before = ones(18,1);

% value portfolio (i.e. before updating)
val_port = ones(18,1);

% value of certificate 
val_cert = ones(18,1);

% abs Hedging error - 
hedg_err = ones(18,1);


%%% first month %%%%

% The values for the first month aere derived outside the simulation 

% stock price
values(1,1) = p1;

% delta - also relative amount of stocks in portfolio - using the function
deltas(1,1) = deltas_compute2(p1, sigma, r, dtg(1,1)/365);



% value of stocks 
stocks_after(1,1) = values(1,1) * deltas(1,1);
stocks_before(1,1) = 0; % starting from 0 - as in the lecture

% value bonds 
bonds_after(1,1) =  table2array(T(3,1)) - stocks_after(1,1) ;  % going short to finance stock buying 
bonds_before(1,1) = 0; % starting from 0 - as in the lecture

% value portfolio
val_port(1,1) = stocks_before(1,1) + stocks_before(1,1);

% value of certificate - using the actual certificate price of 28-02 
val_cert(1,1) = table2array(T(3,1));

% absolute Hedging error 
hedg_err(1,1) = abs( val_cert(1,1) - val_port(1,1) );



%% Further months %%

% simulating one stock path and the associated deltas. 
% Updating the prices of stocks_before and bonds_before
% Updating stocks_after and bonds_after based on the new deltas
% calculating new certificate price based on new stock price
% calculating absolute hedging error as absolute difference of sum of
% stocks_before and bonds_before (i.e. before updating) and certificate
% price



rng(12);

for i = 2:18

     % 1) Stock prices 
     % delta t = 30/365 since the upates of the RP are done on a monthly basis
     values(i, 1) = values((i-1),1) * exp( (r - 0.5 * sigma)*(30/365) + randn(1) * sqrt(sigma)*sqrt(30/365) );
 
    % 2) Updating stocks_before & bonds_before 
    stocks_before(i,1) = stocks_after((i-1),1) * (values(i,1) / values(i,1));
    bonds_before(i,1) = bonds_after((i-1),1) * exp(r * 30/365 );
    
    % 3) Value of the portfolio
    val_port(i,1) = stocks_before(i,1) + bonds_before(i,1);
    
    % 4) Value of the certificate - calculated based on stock price 
    val_cert(i,1) = value_Black_Scholes( values(i,1), sigma, r, dtg(i,1) );

    % 5) Absolute hedging error 
    hedg_err(i,1) = abs( val_cert(i,1) - val_port(i,1) );
    
    % 6) New delta
    deltas(i,1) = deltas_compute2( values(i,1) , sigma, r, dtg(i,1)/365);

    % 7) Updating stocks in portfolio 
    stocks_after(i,1) = values(i,1) * deltas(i,1);

    % 8) Updating bonds in portfolio
   bonds_after(i,1) =  bonds_before(i,1) + (stocks_before(i,1) - stocks_after(i,1) );
    
 
end


%%% creating table %%%

% for the table output, I shall use stocks_before and bonds_before as they
% make of the rpelicating portfolio before reweighting 

replicating_portfolio = table(values, deltas, stocks_before, bonds_before , val_port, val_cert, hedg_err);

% displaying  final row and rows 2,3 (row 1 is useless because some values
% were set to 0). 

disp("Results concerning the replicating portfolio:");
disp("Results for the first two months");
disp(replicating_portfolio(2:3,:));
disp("Results for the final month");
disp(replicating_portfolio(18,:));








%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Performance Analysis %%
%%%%%%%%%%%%%%%%%%%%%%%%%%
rng(1);

%starting from first days of valuation period!
% using the 100-days rolling volatility of stock returns this date as the measure for sigma sqaured 
% running the monte carlo simultion for 575 days, i.e. until maturity

% I shall firsty run the simulation and then consider the associated
% payoffs for a 10,000 € investment 


%% The simulation %%

p1 = table2array(T(1,2));
sigma = table2array(T(1,6)); % using rolling volatility of stock returns for simulation
r = table2array(T(1,10));


% the number of days left to maturity
t = 575;

% simulation 5000 different stock paths (using geometric brownian motion) 

    values = ones(t, 5000);
    
    % starting value = stock price 
    values(1,:) = p1;
    
    % running 5000 simulations from valuation date to  T
    
        for a = 1:5000   
            for i = 2:t
                values(i, a) = values((i-1),a) * exp( (r - 0.5 * sigma)*(1/365) + randn(1) * sqrt(sigma)*sqrt(1/365) );
            end
        end
    
       
        % translating stock price at (T) into payout - also considering if barrier was reached ##
        final_cert_prices = ones(1,5000);
        
        
        % computing minimum values to check if barrier was breached
        mins = ones(1,5000);
        
        for i = 1:5000
            mins(1,i) = min(values(:,i));
        end
        
        % getting the final value depending on barrier breaching and final
        % prices of the underlying
        for i = 1:5000
            if mins(1,i) < 29.65
                final_cert_prices(1,i) = values(t, i);
            else
                final_cert_prices(1,i) = max(values(t, i), 37.5);
            end
        end 
   
    ret_pessimistic = quantile(final_cert_prices, 0.1);
    ret_moderate = quantile(final_cert_prices, 0.5);
    ret_optimistic = quantile(final_cert_prices, 0.9);
    
    
%% Associated payoffs %%     

    % initial investments 
    cert_1 = table2array(T(1,1));
    %10000 / cert_1 = 326.9 - I assume that the investor would have bought
    %326 certificates!
    
    
    ret_p = (326 * ret_pessimistic) / (326 * cert_1) - 1;
    ret_m = (326 * ret_moderate) / (326 * cert_1) - 1;
    ret_o = (326 * ret_optimistic) / (326 * cert_1) - 1;
    
    o1 = 326 * ret_pessimistic;
    o2 = 326 * ret_moderate;
    o3 = 326 * ret_optimistic;
    
    disp("Results for performance analyis");
    disp("In the pessimistic scenario, the investor would end up with " + o1 + "; i.e a return of " + ret_p + ".");
    disp("In the moderate scenario, the investor would end up with " + o2 + "; i.e a return of " + ret_m + ".");
    disp("In the optimistic scenario, the investor would end up with " + o3 + "; i.e a return of " + ret_o + ".");

    
    

%%%%%%%%%%%%%%%%%%%%%
%% Stress scenario %%
%%%%%%%%%%%%%%%%%%%%%
rng(1);

% computing the 5 year - 63 days rolling vola of "ln_returns"
var_stressed_vola = movstd(ln_returns, 63);

[n,x] = hist(var_stressed_vola, 400);
n2 = smoothdata(n);
vola_90 = quantile(var_stressed_vola, 0.9);

%PDF
figure();
plot(x,n2, "blue");
title("PDF of stressed  volatility - smoothed", 'FontSize', 18);
xlabel("Stressed volatility", 'FontSize', 18)
ylabel("Density", 'FontSize', 18, 'LineWidth',1.5);
xline(vola_90, "--", 'LineWidth',2.0);
legend({"Stressed volatility","90%-quantile"}, 'Location','northeast', 'FontSize', 18);
grid();

%CDF
[n,x] = ecdf(var_stressed_vola);
n2 = smoothdata(n);

figure();
plot(x,n2, "blue");
title("CDF of stressed  volatility - smoothed", 'FontSize', 18);
xlabel("Stressed volatility", 'FontSize', 18)
ylabel("Cumulative Density", 'FontSize', 18, 'LineWidth',1.5);
xline(vola_90, "--", 'LineWidth',2.0);
legend({"Stressed volatility", "90%-quantile"}, 'Location','southeast', 'FontSize', 18);
grid();

% simulating the developments with increased sigma
sigma = vola_90;

% starting again on 26-02-2021
t = 575;

% like above, simulation 5000 times 
values = ones(t, 5000);
    
% starting value = stock price 
values(1,:) = p1;
    
% running 5000 simulations from valuation date to  T using geometric
% browninan motion 

% fixing r at first date of valuation period 
r = table2array(DATA_TABLE_ALL(1,10));

        for a = 1:5000   
            for i = 2:t
                values(i, a) = values((i-1),a) * exp( (r - 0.5 * sigma)*(1/365) + randn(1) * sqrt(sigma)*sqrt(1/365) );
            end
        end
    
       
% translating stock price at (T) into payout - also considering if barrier was reached ##
final_cert_prices = ones(1,5000);
mins = ones(1,5000);
        
% computing minimum values to check if barrier was breached
       for i = 1:5000
           mins(1,i) = min(values(:,i));
        end
        
        % getting the final value depending on barrier breaching and final
        % prices of the underlying
        for i = 1:5000
            if mins(1,i) < 29.65
                final_cert_prices(1,i) = values(t, i);
            else
                final_cert_prices(1,i) = max(values(t, i), 37.5);
            end
        end 
    

        % 5% quantle of final certificate prices
    certificate_disc_q_5 = quantile( final_cert_prices, 0.005);
    
    %%% return 
    o1 = certificate_disc_q_5 * 326;
    o2 = (certificate_disc_q_5 * 326) / (cert_1 * 326) -1;
    
    disp("Results for the stress analysis:");
    disp("In this case of increase volatility and when taking the 5% quantile of the payoff distribution, an investor would end up with " + o1 + "€, which is a " + -1*o2 + " decrease");
    
   
    
    
 %%%%%%%%%%%%%%%%%%%%%%%%%
 %% Risk classification %%
 %%%%%%%%%%%%%%%%%%%%%%%%%
 
rng(1);
% getting it (again) by 5000 simulations and discouting the prices 
% again treating 26-02-2021 as t0
% using the 100-days rolling volatility of stock returns as the vola

p1 = table2array(T(1,2));
sigma= table2array(T(1,6)); % 
r = table2array(T(1,10));

% the number of days left to maturity
t = 575;

% like above, simulation 5000 times 

    values = ones(t, 5000);
    
    % starting value = stock price 
    values(1,:) = p1;
    
    % running 5000 simulations from valuation date to  T
    
        for a = 1:5000   
            for i = 2:t
                values(i, a) = values((i-1),a) * exp( (r - 0.5 * sigma)*(1/365) + randn(1) * sqrt(sigma)*sqrt(1/365) );
            end
        end
    
       
        % translating stock price at (T) into payout - also considering if barrier was reached ##
        final_cert_prices = ones(1,5000);
        
        mins = ones(1,5000);
        
        % computing minimum values to check if barrier was breached
        for i = 1:5000
            mins(1,i) = min(values(:,i));
        end
        
        % getting the final value depending on barrier breaching and final
        % prices of the underlying
        for i = 1:5000
            if mins(1,i) < 29.65
                final_cert_prices(1,i) = values(t, i);
            else
                final_cert_prices(1,i) = max(values(t, i), 37.5);
            end
        end 
        
        % discounting the certificate prices - as stated in the assignment
        cert_prices_disc   =  final_cert_prices * exp(-r*(t/365));
        
        
% calculating the 2.5% of the relative payouts 
relative_payouts = cert_prices_disc / cert_1;
var_2_5 = quantile(relative_payouts, 0.025);
        
% calculating the VEV 
VEV = (sqrt(3.842 - 2* log(var_2_5) ) -1.96   ) / sqrt(t/356);


% deriving MRM 

if VEV < 0.005
    MRM = 1;
elseif VEV < 0.05
    MRM = 2;
elseif VEV < 0.12
    MRM = 3;
elseif VEV < 0.2
    MRM = 4;
elseif VEV < 0.3
    MRM = 5;
elseif VEV < 0.8
    MRM = 6;
else    
    MRM = 7;
end

disp("Result for the risk classification");
disp("The VEV calcuated is " + VEV + ", which corresponds to a MRM class of " + MRM + ".");

%%%%%%%%%%%%%%%
% end of code %
%%%%%%%%%%%%%%%
